\documentclass[format=sigplan,review=false,screen=true]{acmart}\settopmatter{}

\usepackage[para]{footmisc}   %% gather footnotes on a single line

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{supertabular}
\usepackage{stmaryrd}
\usepackage{color}
\usepackage{multirow}
\usepackage{calc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{dashrule}  % for \hdashrule
\usepackage{stackrel}
\usepackage{enumerate}
\usepackage{framed}
\usepackage{bussproofs}
\usepackage{mdframed}  % highlight
\usepackage{hyperref}
\usepackage{comment}
%\usepackage{natbib}
\usepackage{ifthen}
\usepackage{pdftexcmds}

\usepackage{mathpartir}
\usepackage{ottalt}

\usepackage{fancyvrb}

\usepackage{listings}
\lstset{language=Haskell}

%\special{papersize=8.5in,11in}
%\setlength{\pdfpageheight}{\paperheight}
%\setlength{\pdfpagewidth}{\paperwidth}

%\usepackage{palatino}
\renewcommand{\familydefault}{\rmdefault}
%\renewcommand{\ttdefault}{cmtt}

%% Show admissible premises in rules
%% This should be false in main body of text and true in the appendix.
\newif\ifadmissible
\admissiblefalse
\newcommand\suppress[1]{\ifadmissible{[#1]}\else{}\fi}
\inputott{ett-rules}


\newcommand{\alt}{\ |\ }
\newcommand{\rul}[1]{\rref{#1}}


\newcommand{\fc}{DC\xspace}
\newcommand{\fimp}{D\xspace}
\newcommand{\pico}{\textsc{PiCo}\xspace}


\newif\ifcomments
\commentstrue
\ifcomments
\newcommand{\scw}[1]{\textcolor{blue}{{SCW: #1}}}
\newcommand{\rae}[1]{\textcolor{magenta}{{RAE: #1}}}
\newcommand\av[1]{\textcolor{orange}{{AV: #1}}}
\else
\newcommand{\scw}[1]{}
\newcommand{\rae}[1]{}
\newcommand\av[1]{}
\fi




%% allow more interline spacing (and fewer overfull hboxes).
\tolerance=5000

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
%\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}


\title{A specification of eta-equivalence in LNrep}

\author{Stephanie Weirich}
\orcid{0000-0002-6756-9168}
\affiliation{
  \position{Professor}
  \department{Computer and Information Science}              %% \department is recommended
  \institution{University of Pennsylvania}            %% \institution is required
  \streetaddress{3330 Walnut St}
  \city{Philadelphia}
  \state{PA}
  \postcode{19104}
  \country{USA}
}
\email{sweirich@cis.upenn.edu}

\author{Antoine Voizard}
\affiliation{
  \position{}
  \department{}              %% \department is recommended
  \institution{University of Pennsylvania}            %% \institution is required
  \streetaddress{}
  \city{}
  \state{}
  \postcode{}
  \country{USA}
}
\email{voizard@seas.upenn.edu}

\author{Anastasiya Kravchuk-Kirilyuk}
\affiliation{
  \position{}
  \department{}              %% \department is recommended
  \institution{University of Pennsylvania}            %% \institution is required
  \streetaddress{}
  \city{}
  \state{}
  \postcode{}
  \country{USA}
}
\email{akravc@sas.upenn.edu}

\begin{abstract}
abstract - do we need one? Is a good introduction enough?
\scw{Two sentences}
\end{abstract}

\maketitle

%% Our running head is too long for acmsmall
\renewcommand{\shortauthors}{Weirich, Voizard}

Disclaimer: the current prose will need a loooot of refinement/improvement

\section{Introduction}

%% first sentence sounds long - need to break it up a bit.


The Corespec project~\cite{Weirich:systemd} is an extensive  mechanization in Coq of the metatheory of System D and System DC,
two related, dependently-typed languages aimed at replacing GHC's internal language, Core. In this talk, we
take a fresh (?) look at our development through the lens of a recent addition, the $\eta$-reduction rules. In
particular, this will allow us to explore (?) the practical application of locally nameless variable-binding representation
for mechanized metatheory.

\section{Corespec}
The idea behind Corespec is to provide a replacement for GHC Core that supports full spectrum dependent types.
Specifically, this requires untangling the notions of type on the one hand and of erasable component (computationally irrelevant)
on the other - which current GHC essentially conflates.

The problem with such design (which design?) is that the resulting language(s), which combine several important features (dependent types, irrelevance,
explicit type coercions, non-termination) is/are quite complex, with a design tricky to get precisely right. This is the main reason why
mechanizing our formalization in Coq has been invaluable in getting strong confidence in our results, but also in designing the system
in the first place (although we were also building on previous results).
In particular, it is important to note that the mechanization was no afterthought -
we designed these new languages while mechanizing their metatheory.

\scw{That is only sort-of true. There were many many papers about FC that we
  drew from. Even though this was a differnt system, and mechanization lead to
new designs, such as AnRefl2, we weren't working from scratch.}
\av{Well, I agree with you, but I don't really see how this goes against the current version..? I tried changing it a bit, is that better?}
Potential ideas: the "breaking the design + recompiling" methodology

\scw{We need to explain much more precisely about what definitions are
  provided by Ott, what lemmas are provided by
  lngen, and what we actually proved.  maybe pick some representative
  lemmas such as confluence to state?}

\subsection{Locally Nameless representation}
To represent variable bindings, we have use a locally nameless encoding in this project.~\cite{aydemir:popl-binders}
In this representation, bound variables use de Bruijn indices while free variables use explicit names instead.
\av{Do we need to explain briefly what that is?}\scw{yes a bit}

To help us manipulate the representation more conveniently, we have relied on 2 main tools.

The first, Ott~\cite{Ott}, is a specification tool that makes it easier to define programming languages. One can think of it as a compiler for its specification language.
It takes as input rules of the shape as shown below \av{ref} -
that is, an user-definable ascii representation of the syntax, judgment and rules of the language. It outputs a representation of it in another
format - for instance, \LaTeX, or Coq with a locally-nameless representation (abbreviated Coq/LN in the following). \av{bad sentence}.
For instance, rule \av{refs} XXXX as show in figure XXXX
gets compiled to the case XXXX shown in figure XXXXX (this is a constructor of the inductive type that ott defines to represent the reduction judgment).

The second tool, LNgen~\cite{aydemir:lngen}, is a complement to Ott when used to output Coq/LN.
It derives a large amount of helper lemmas about the Coq/LN code that Ott generated.
For instance, \av{What? Should we mention close?}
In almost any reasoning about LN terms, one needs to rely on some of these lemmas to keep the proofs manageable and high-level. \av{Not great}


How do we specify eta-reduction using the locally nameless representation?

As part of a larger proof development, we added eta reduction using the
following rule:

...

\scw{This rule captures the free variable condition because it allows x to
  appear in a (because a is under the binder \\x) but x cannot appear in b
(because b doesn't appear under the binder).}

\section{Case study: Eta}

Here is how we represent the $\eta$-reduction (in the parallel reduction relation) in a simplified version of the language:
\begin{verbatim}
 |- b => b'
a = b x
----------------------------- :: Eta
 |- \ x. a => b'
\end{verbatim}
This should look somewhat unusual. Indeed, why are we not asserting that $[[x `notin` fv b]]$?
The answer is, this condition \emph{is} actually enforced, although somewhat indirectly. Notice that, in
the conclusion, $[[a]]$ appears under the binder. This prompts Ott to output a definition in which $[[x]]$ can
appear in $[[a]]$, as it is aware that $\lambda$ is a binder.
Now, notice the second premise of the rule - in particular the fact that no side of the
equation is under a binder. This means that in the definition generated by Ott, $[[x]]$ can \emph{not}
appear in $[[b]]$. This results in the proper semantics for this rule.

\scw{Here is the rule that we might imagine writing in Ott. Sadly, it is
  outside the scope of what the LN backend for Ott can handle.  }

Despite this, one might rightly (\av{rightly?}) wonder why we are not using this more direct version of the rule instead:
\begin{verbatim}
 |- b => b'
x `notin` fv b
----------------------------- :: EtaPaper?
 |- \ x. b x => b'
\end{verbatim}
The answer is simple: the LN backend of Ott unfortunately can't handle that definition. \av{Not proud of the writing}


When using Ott for a simplified version of the language (here simply the $\lambda$-calculus), one obtains the following
inductive type to represent the syntax:
\begin{verbatim}
Induction exp :=
   | var_f : atom -> exp
   | var_b : nat -> exp
   | abs   : exp -> exp
   | app   : exp -> exp -> exp
\end{verbatim}
As expected, we get a locally nameless representation: variables have 2 constructors, one for bound variables that
uses a de Bruijn representation, and another for free variables that relies on a set of names (\verb!atom!).

Ott outputs another inductive type that represents the parallel reduction judgment; here is the case (constructor)
generated for the $\eta$ rule above:
\begin{verbatim}
Par_Eta : forall (L:vars) (a b b' : Exp),
  Par b b' ->
  (forall x, x notin L -> open a x = app b x) ->
  Par (abs a) b'
\end{verbatim}
It relies on the co-finite quantification over the complement of \verb!L!, an universally quantified finite set.
\av{Todo: explain the spirit of this representation}


While this version works well for backward reasoning, it is quite horrible to use in forward reasoning,
which we occasionally have to do. This is why one might want an \emph{existential} version, such as this
one:

\begin{verbatim}
Par_Eta : forall a b b' x,
  x notin ???
  Par b b' ->
  open a x = app b x ->
  Par (abs a) b'
\end{verbatim}
This is a version of the rule we prove is admissible in our development. Not only this is a more useful form
of the rule for some cases, but this is also a great way to check that we indeed defined the \av{semantics? system? language?}
that we intended.

Alternative close version
Finally, here is a last version of the rule one might want to use. It relies on the closing operation \av{where should we define close, here
or earlier?}, which takes a term with a dangling de Bruijn index (for bound variables) and substitutes it with the free variable $[[x]]$.
\begin{verbatim}
Par_Eta : forall a b x,
  Par a b ->
  Par (abs (close x (app a (var_f x)))) b
\end{verbatim}
\av{Explain why it encodes the free var condition}
Otherwise, this version has similar properties to the previous one. It is not really handy for backward reasoning, since rewriting the
term in the conclusion to have this specific shape might take quite a bit of reasoning. However, it is convenient for forward reasoning
(especially since $[[a]]$ may in some cases be a term of the shape \verb!open (...)!, and
Lngen provides several lemmas to easily rewrite interactions of \verb!open! and \verb!close!), and it is also
a good check on the meaning of what we're defining. \av{bad writing...}



\section{Lessons learned}
\scw{These lessons are far too general for coqpl.  that group already believes in
  the benefit of mechanization, so won't be impressed by general statements
  about the usefulness of coq for pl. } \av{Ok}


\scw{Here's how to make it concrete: we can mention the inversion lemma that
  doesn't hold. Not only is this something that surprised me, but it is also
  good to know that we don't need it to hold.}
\begin{lemma}[Inversion]
if $[[G |= \x.b x : Pi x : A.B ]]$ and $[[ x `notin` fv b]]$ then $[[ G |= b :
Pi x:A.B ]]$.
\end{lemma}
The lemma fails because the erased language only mentions variables in
computationally relevant positions. However, we could have used x implicitly,
such as in instantiating a polymorphic function.

Because this lemma doesn't hold, our parallel reduction relation does not have
the preservation property. The rule above allows the term to reduce, in some
cases to an ill-typed term.  However, none of the rest of the metatheory
relies on preservation for parallel reduction---and we can verify that easily
with the proof scripts.

- Collaboration benefit: we were able to bring in a new collaborator (Ana)
after all of the proofs were done, and she could make progress without having
to understand the entire development. \scw{Ana, can you say anything specific
about joining this scale of project?}


\bibliography{../icfp17/weirich.bib,../icfp17/proposal.bib,../icfp17/rae.bib,coqpl.bib}

\end{document}




%% Local Variables:
%% mode: LaTeX
%% End:

%%  LocalWords:  interline overfull hboxes papersize FL Ahmed eir sweirich HM
%%  LocalWords:  Hamidhasan taun SCW lncs urgh app rccll damas milner HMV SB
%%  LocalWords:  Damas's outsidein SB's ghc Expr normalizePoly normalizeProxy
%%  LocalWords:  normalizeExpr TypeApplications AllowAmbiguousTypes APIs API
%%  LocalWords:  ICFP Refl SCond MonadReader MonadWriter RAE polytype const
%%  LocalWords:  NB SwapPair swapPair sP HM's monotypes Barendregt Gen InstG
%%  LocalWords:  monotype vars InstS hmv Abs TApp Var V's Annot algv foo DAbs
%%  LocalWords:  RankNTypes metatheorems skolemization inst'd DeepSkol Skol
%%  LocalWords:  Twelf Dreyer Blume's ML's DK Neel Krishnaswami Didier hlio
%%  LocalWords:  TypeOperators DataKinds PolyKinds ConstraintKinds Typeable
%%  LocalWords:  ScopedTypeVariables woozle boolCast eqT unsafeThe Val Cond
%%  LocalWords:  eval SExpr sEval SBool SVal sIf Inst IFPOP ListInst infixr
%%  LocalWords:  STrue SFalse supertype checkIf myId myAbs abs Num GHCi ghci
%%  LocalWords:  fromInteger myPair MkG pr Ty forall ol pid cc hm sp inst gen
%%  LocalWords:  sb dn pf sf ys xs se
